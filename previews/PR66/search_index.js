var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TrixiAtmo","category":"page"},{"location":"#TrixiAtmo","page":"Home","title":"TrixiAtmo","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TrixiAtmo.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TrixiAtmo]","category":"page"},{"location":"#TrixiAtmo.TrixiAtmo","page":"Home","title":"TrixiAtmo.TrixiAtmo","text":"üåç TrixiAtmo üåç\n\nTrixiAtmo.jl is a simulation package for atmospheric models based on Trixi.jl\n\nSee also: trixi-framework/TrixiAtmo.jl\n\n\n\n\n\n","category":"module"},{"location":"#TrixiAtmo.AbstractCovariantEquations","page":"Home","title":"TrixiAtmo.AbstractCovariantEquations","text":"AbstractCovariantEquations{NDIMS, \n                           NDIMS_AMBIENT, \n                           GlobalCoordinateSystem,\n                           NVARS} <: AbstractEquations{NDIMS, NVARS}\n\nAbstract type used to dispatch on systems of equations in covariant form, in which fluxes and prognostic variables are stored and computed in terms of their contravariant components  defining their expansions in terms of the local covariant tangent basis. The type parameter NDIMS denotes the dimension of the manifold on which the equations are solved, while NDIMS_AMBIENT is the dimension of the ambient space in which such a manifold is embedded.  Some references on discontinuous Galerkin methods in covariant flux form are listed below:\n\nM. Baldauf (2020). Discontinuous Galerkin solver for the shallow-water equations in covariant form on the sphere and the ellipsoid. Journal of Computational Physics  410:109384. DOI: 10.1016/j.jcp.2020.109384 \nM. Baldauf (2021). A horizontally explicit, vertically implicit (HEVI) discontinuous Galerkin scheme for the 2-dimensional Euler and Navier-Stokes equations using  terrain-following coordinates. Journal of Computational Physics 446:110635. DOI: 10.1016/ j.jcp.2021.110635\nL. Bao, R. D. Nair, and H. M. Tufo (2014). A mass and momentum flux-form high-order discontinuous Galerkin shallow water model on the cubed-sphere. A mass and momentum  flux-form high-order discontinuous Galerkin shallow water model on the cubed-sphere.  Journal of Computational Physics 271:224-243.  DOI: 10.1016/j.jcp.2013.11.033\n\nWhen using this equation type, functions which are evaluated pointwise, such as fluxes,  source terms, and initial conditions take in the extra argument aux_vars, which contains  the geometric information needed for the covariant form. The type parameter  GlobalCoordinateSystem specifies the global coordinate system used to define the  covariant tangent basis, and may be either GlobalCartesianCoordinates or  GlobalSphericalCoordinates. The GlobalCoordinateSystem type parameter also  specifies the coordinate system with respect to which the initial condition should be  prescribed.\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.CovariantLinearAdvectionEquation2D","page":"Home","title":"TrixiAtmo.CovariantLinearAdvectionEquation2D","text":"CovariantLinearAdvectionEquation2D{GlobalCoordinateSystem} <:  \n    AbstractCovariantEquations{2, 3, GlobalCoordinateSystem, 3}\n\nA variable-coefficient linear advection equation can be defined on a two-dimensional manifold S subset mathbbR^3 as\n\npartial_t h + nabla_S cdot (h vecv) = 0\n\nwhere nabla_S cdot is the horizontal divergence operator on S. We treat this problem  as a system of equations in which the first variable is the scalar conserved quantity h,  and the second two are the contravariant components v^1 and v^2 used in the expansion  with respect to the covariant basis vectors veca_1 and veca_2 as\n\nvecv = v^1 veca_1 + v^2 veca_2\n\nwhere veca_1 = partial vecx  partial xi^1 and  veca_2 = partial vecx  partial xi^2 are the so-called covariant basis vectors,  and xi^1 and xi^2 are the local reference space coordinates. The velocity components  are spatially varying but assumed to be constant in time, so we do not apply any flux or  dissipation to such variables. The resulting system is then given on the reference element  as \n\nJ fracpartialpartial t\nleftbeginarrayc h  v^1  v^2 endarrayright \n+\nfracpartialpartial xi^1 \nleftbeginarrayc J h v^1  0  0 endarrayright\n+ \nfracpartialpartial xi^2 \nleftbeginarrayc J h v^2  0  0 endarrayright \n= \nleftbeginarrayc 0  0  0 endarrayright\n\nwhere J = lVertveca^1 times veca^2 rVert is the area element. Note that the  variable advection velocity components could alternatively be stored as auxiliary  variables, similarly to the geometric information.\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.CovariantShallowWaterEquations2D","page":"Home","title":"TrixiAtmo.CovariantShallowWaterEquations2D","text":"CovariantShallowWaterEquations2D{GlobalCoordinateSystem} <:  \n    AbstractCovariantEquations{2, 3, GlobalCoordinateSystem, 3}\n\nDenoting the covariant derivative by  nabla_b and summing over repeated indices, the shallow water equations can be expressed  on a two-dimensional surface in three-dimensional ambient space as\n\nbeginaligned\npartial_t h + nabla_b (hv^b) = 0\npartial_t (hv^a) + nabla_b (hv^av^b) + gh G^abpartial_b(h + b) \n= -fJ G^abvarepsilon_bc hv^c\nendaligned\n\nwhere h is the fluid height, v^a and G^ab are the contravariant velocity and metric  tensor components, g is the gravitational constant, f is the Coriolis parameter,  J is the area element, and partial_a is used as a shorthand for  partial  partial xi^a. Combining the advective and pressure terms in order to define  the momentum flux components\n\ntau^ab = hv^a v^b + frac12G^abgh^2\n\nthe covariant shallow water equations can be expressed as a system of conservation laws  with a source term (implemented in the exported function  source_terms_geometric_coriolis), as given by\n\nJ fracpartialpartial t\nleftbeginarrayc h  hv^1  hv^2 endarrayright \n+\nfracpartialpartial xi^1 \nleftbeginarrayc J h v^1  J tau^11  J tau^12 endarrayright\n+ \nfracpartialpartial xi^2 \nleftbeginarrayc J h v^2  J tau^21  J tau^22  endarrayright \n= J leftbeginarrayc 0  \n-Gamma^1_actau^ac - f J big(G^12hv^1 - G^11hv^2big)  \n-Gamma^2_actau^ac - f J big(G^22hv^1 - G^21hv^2big)\n endarrayright\n\nNote that the geometric contribution to the source term involves the Christoffel symbols of the second kind, which can been expressed in terms of the covariant metric tensor components G_ab as \n\nGamma_ac^b = \nfrac12G^bdbig(partial_aG_cd + partial_c G_da - partial_d G_acbig)\n\nReferences\n\nM. Baldauf (2020). Discontinuous Galerkin solver for the shallow-water equations in covariant form on the sphere and the ellipsoid. Journal of Computational Physics  410:109384. DOI: 10.1016/j.jcp.2020.109384 \nL. Bao, R. D. Nair, and H. M. Tufo (2014). A mass and momentum flux-form high-order discontinuous Galerkin shallow water model on the cubed-sphere. A mass and momentum  flux-form high-order discontinuous Galerkin shallow water model on the cubed-sphere.  Journal of Computational Physics 271:224-243.  DOI: 10.1016/j.jcp.2013.11.033\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.GlobalCartesianCoordinates","page":"Home","title":"TrixiAtmo.GlobalCartesianCoordinates","text":"GlobalCartesianCoordinates()\n\nStruct used for dispatch, specifying that the covariant tangent basis vectors should be  defined with respect to a global Cartesian coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.GlobalSphericalCoordinates","page":"Home","title":"TrixiAtmo.GlobalSphericalCoordinates","text":"GlobalSphericalCoordinates()\n\nStruct used for dispatch, specifying that the covariant tangent basis vectors should be  defined with respect to a global spherical coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.MetricTermsCrossProduct","page":"Home","title":"TrixiAtmo.MetricTermsCrossProduct","text":"MetricTermsCrossProduct()\n\nStruct used for multiple dispatch on functions that compute the metric terms. When the argument metric_terms is of type MetricTermsCrossProduct, the  contravariant vectors are computed using the cross-product form.\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.MetricTermsInvariantCurl","page":"Home","title":"TrixiAtmo.MetricTermsInvariantCurl","text":"MetricTermsInvariantCurl()\n\nStruct used for multiple dispatch on functions that compute the metric terms. When the argument metric_terms is of type MetricTermsInvariantCurl, the  contravariant vectors are computed using the invariant curl form.\n\nReferences\n\nKopriva, D. A. (2006). Metric identities and the discontinuous spectral element method on  curvilinear meshes. Journal of Scientific Computing 26, 301-327.  DOI: 10.1007/s10915-005-9070-8\nVinokur, M. and Yee, H. C. (2001). Extension of efficient low dissipation high order schemes for 3-D curvilinear moving grids. In Caughey, D. A., and Hafez, M. M. (eds.), Frontiers of Computational Fluid Dynamics 2002, World Scientific, Singapore, pp. 129‚Äì164. DOI: 10.1142/9789812810793_0008\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.ShallowWaterEquations3D","page":"Home","title":"TrixiAtmo.ShallowWaterEquations3D","text":"ShallowWaterEquations3D(; gravity, H0 = 0)\n\nShallow water equations (SWE) in three space dimensions in conservation form (with constant bottom topography).  The equations are given by\n\nbeginaligned\n  fracpartial hpartial t + fracpartialpartial x(h v_1)\n    + fracpartialpartial y(h v_2) + fracpartialpartial z(h v_3) = 0 \n    fracpartialpartial t(h v_1) + fracpartialpartial xleft(h v_1^2 + fracg2h^2right)\n    + fracpartialpartial y(h v_1 v_2) + fracpartialpartial z(h v_1 v_3) = 0 \n    fracpartialpartial t(h v_2) + fracpartialpartial x(h v_1 v_2)\n    + fracpartialpartial yleft(h v_2^2 + fracg2h^2right) + fracpartialpartial z(h v_2 v_3) = 0 \n    fracpartialpartial t(h v_3) + fracpartialpartial x(h v_1 v_3)\n    + fracpartialpartial y(h v_2 v_3) + fracpartialpartial zleft(h v_3^2 + fracg2h^2right) = 0\nendaligned\n\nThe unknown quantities of the SWE are the water height h and the velocities mathbfv = (v_1 v_2 v_3)^T. The gravitational constant is denoted by g.\n\nThe 3D Shallow Water Equations (SWE) extend the 2D SWE to model shallow water flows on 2D manifolds embedded within 3D space.  To confine the flow to the 2D manifold, a source term incorporating a Lagrange multiplier is applied.  This term effectively removes momentum components that are normal to the manifold, ensuring the flow remains  constrained within the 2D surface.\n\nThe additional quantity H_0 is also available to store a reference value for the total water height that is useful to set initial conditions or test the \"lake-at-rest\" well-balancedness.\n\nIn addition to the unknowns, Trixi.jl currently stores the bottom topography values at the approximation points despite being fixed in time. This is done for convenience of computing the bottom topography gradients on the fly during the approximation as well as computing auxiliary quantities like the total water height H or the entropy variables. This affects the implementation and use of these equations in various ways:\n\nThe flux values corresponding to the bottom topography must be zero.\nThe bottom topography values must be included when defining initial conditions, boundary conditions or source terms.\nAnalysisCallback analyzes this variable.\nTrixi.jl's visualization tools will visualize the bottom topography by default.\n\nReferences:\n\nJ. Cot√© (1988). \"A Lagrange multiplier approach for the metric terms of semi-Lagrangian models on the sphere\".  Quarterly Journal of the Royal Meteorological Society 114, 1347-1352. DOI: 10.1002/qj.49711448310\nF. X. Giraldo (2001). \"A spectral element shallow water model on spherical geodesic grids\".  DOI: 10.1002/1097-0363(20010430)35:8<869::AID-FLD116>3.0.CO;2-S\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.SplitCovariantShallowWaterEquations2D","page":"Home","title":"TrixiAtmo.SplitCovariantShallowWaterEquations2D","text":"SplitCovariantShallowWaterEquations2D{GlobalCoordinateSystem} <:  \n    AbstractCovariantEquations{2, 3, GlobalCoordinateSystem, 3}\n\nAlternative flux formulation of CovariantShallowWaterEquations2D given on the  reference element by \n\nJ fracpartialpartial t\nleftbeginarrayc h  hv^1  hv^2 endarrayright \n+\nfracpartialpartial xi^1 \nleftbeginarrayc J h v^1  J h v^1 v^1  J h v^2 v^1 endarrayright\n+ \nfracpartialpartial xi^2 \nleftbeginarrayc J h v^2  J h v^1 v^2  J h v^2 v^2 endarrayright \n+\nJ leftbeginarrayc 0  Upsilon^1  Upsilon^2 endarrayright \n= \nJleftbeginarrayc0  s^1  s^2 endarrayright\n\nIn the above, the non-conservative differential terms in the momentum equations are given by\n\nUpsilon^a = frac12hu^bbig(G^acpartial_b u_c - partial_b u^abig) \n+ ghG^abpartial_b h\n\nand the algebraic momentum source terms implemented in source_terms_geometric_coriolis  are given by\n\ns^a = frac12big(Gamma_bc^a hu^bu^c - G^acGamma_bc^d hu^b u_d big) \n- f JG^abvarepsilon_bc hu^c\n\nwhere we use the same notation as in CovariantShallowWaterEquations2D (including  summation over repeated indices) and note that the covariant velocity components are given  by u_a = G_ab u^b. To obtain an entropy-conservative scheme with respect to the total  energy\n\nS = frac12h(u_1 u^1 + u_2u^2)  + frac12gh^2\n\nthis equation type should be used with volume_flux = (flux_ec, flux_nonconservative_ec).\n\nwarning: Experimental implementation\nThe use of entropy-stable split-form/flux-differencing formulations for covariant  equations is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"#Trixi.flux_fjordholm_etal-Tuple{Any, Any, AbstractVector, ShallowWaterEquations3D}","page":"Home","title":"Trixi.flux_fjordholm_etal","text":"flux_fjordholm_etal(u_ll, u_rr, orientation,\n                    equations::ShallowWaterEquations1D)\n\nTotal energy conservative (mathematical entropy for shallow water equations). When the bottom topography is nonzero this should only be used as a surface flux otherwise the scheme will not be well-balanced. For well-balancedness in the volume flux use flux_wintermeyer_etal.\n\nDetails are available in Eq. (4.1) in the paper:\n\nUlrik S. Fjordholm, Siddhartha Mishr and Eitan Tadmor (2011) Well-balanced and energy stable schemes for the shallow water equations with discontinuous topography DOI: 10.1016/j.jcp.2011.03.042\n\n\n\n\n\n","category":"method"},{"location":"#Trixi.flux_wintermeyer_etal-Tuple{Any, Any, AbstractVector, ShallowWaterEquations3D}","page":"Home","title":"Trixi.flux_wintermeyer_etal","text":"flux_wintermeyer_etal(u_ll, u_rr, orientation_or_normal_direction,\n                      equations::ShallowWaterEquations2D)\n\nTotal energy conservative (mathematical entropy for shallow water equations) split form. When the bottom topography is nonzero this scheme will be well-balanced when used as a volume_flux. For the surface_flux either flux_wintermeyer_etal or flux_fjordholm_etal can be used to ensure well-balancedness and entropy conservation.\n\nFurther details are available in Theorem 1 of the paper:\n\nNiklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry DOI: 10.1016/j.jcp.2017.03.036\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.P4estMeshCubedSphere2D-Tuple{Any, Any}","page":"Home","title":"TrixiAtmo.P4estMeshCubedSphere2D","text":"P4estMeshCubedSphere2D(trees_per_face_dimension, radius;\n                        polydeg, RealT=Float64,\n                        initial_refinement_level=0, unsaved_changes=true,\n                        p4est_partition_allow_for_coarsening=true,\n                        element_local_mapping=false)\n\nBuild a \"Cubed Sphere\" mesh as a 2D P4estMesh with 6 * trees_per_face_dimension^2 trees.\n\nThe mesh will have no boundaries.\n\nArguments\n\ntrees_per_face_dimension::Integer: the number of trees in the two local dimensions of                                      each face.\nradius::Integer: the radius of the sphere.\npolydeg::Integer: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.\nRealT::Type: the type that should be used for coordinates.\ninitial_refinement_level::Integer: refine the mesh uniformly to this level before the simulation starts.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\np4est_partition_allow_for_coarsening::Bool: Must be true when using AMR to make mesh adaptivity independent of domain partitioning. Should be false for static meshes to permit more fine-grained partitioning.\nelement_local_mapping::Bool: option to use the alternative element-local mapping from Appendix A of Guba et al. (2014). If set to  true, the four corner vertex positions for each element will be obtained through an  equiangular gnomonic projection (Ronchi et al. 1996), and the tree node coordinates within the element (i.e. the field  tree_node_coordinates) will be obtained by first using a bilinear mapping based on the  four corner vertices, and then projecting the bilinearly mapped nodes onto the spherical  surface by normalizing the resulting Cartesian coordinates and scaling by  radius. If  set to false, the equiangular gnomonic projection will be used for all tree node  coordinates.\n\nwarning: Warning\nAdaptivity and MPI parallelization are not yet supported for equations in covariant  form, and we require initial_refinement_level = 0 for such cases. Furthermore, the  calculation of the metric terms for the covariant form currently requires polydeg to  be equal to the polynomial degree of the solver, and element_local_mapping = true.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.P4estMeshQuadIcosahedron2D-Tuple{Any, Any}","page":"Home","title":"TrixiAtmo.P4estMeshQuadIcosahedron2D","text":"P4estMeshQuadIcosahedron2D(trees_per_face_dimension, radius;\n                           polydeg, RealT=Float64,\n                           initial_refinement_level=0, unsaved_changes=true,\n                           p4est_partition_allow_for_coarsening=true)\n\nBuild a quad-based icosahedral mesh as a 2D P4estMesh with 60 * trees_per_face_dimension^2 trees (20 triangular faces of the icosahedron, each subdivided into 3 parent quads, each of which subdivided into trees_per_face_dimension^2 trees).\n\nThe node coordinates of the trees will be obtained using the element-local mapping from Appendix A of Guba et al. (2014).  See P4estMeshCubedSphere2D for more information about the element-local mapping.\n\nThe mesh will have no boundaries.\n\nArguments\n\ntrees_per_face_dimension::Integer: the number of trees in the two local dimensions of                                      each parent quad.\nradius::Integer: the radius of the sphere.\npolydeg::Integer: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.\nRealT::Type: the type that should be used for coordinates.\ninitial_refinement_level::Integer: refine the mesh uniformly to this level before the simulation starts.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\np4est_partition_allow_for_coarsening::Bool: Must be true when using AMR to make mesh adaptivity independent of domain partitioning. Should be false for static meshes to permit more fine-grained partitioning.\n\nwarning: Warning\nAdaptivity and MPI parallelization are not yet supported for equations in covariant  form, and we require initial_refinement_level = 0 for such cases. Furthermore, the  calculation of the metric terms for the covariant form currently requires polydeg to  be equal to the polynomial degree of the solver.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.clean_solution_lagrange_multiplier!-Tuple{Any, ShallowWaterEquations3D, Any}","page":"Home","title":"TrixiAtmo.clean_solution_lagrange_multiplier!","text":"     clean_solution_lagrange_multiplier!(u, equations::ShallowWaterEquations3D, normal_direction)\n\nFunction to apply Lagrange multiplier discretely to the solution in order to constrain  the momentum to a 2D manifold.\n\nThe vector normal_direction is perpendicular to the 2D manifold. By default,  this is the normal contravariant basis vector.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.contravariant2global","page":"Home","title":"TrixiAtmo.contravariant2global","text":"contravariant2global(u, aux_vars, equations)\n\nTransform the vector u of solution variables with the momentum or velocity given in terms  of local contravariant components into the global coordinate system specified by the  GlobalCoordinateSystem type parameter in AbstractCovariantEquations. u is a  vector type of the correct length nvariables(equations). Notice the function doesn't  include any error checks for the purpose of efficiency, so please make sure your input is  correct. The inverse conversion is performed by global2contravariant.\n\n\n\n\n\n","category":"function"},{"location":"#TrixiAtmo.examples_dir-Tuple{}","page":"Home","title":"TrixiAtmo.examples_dir","text":"examples_dir()\n\nReturn the directory where the example files provided with TrixiAtmo.jl are located. If TrixiAtmo.jl is installed as a regular package (with ]add Trixi), these files are read-only and should not be modified. To find out which files are available, use, e.g., readdir:\n\nExamples\n\nreaddir(examples_dir())\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.global2contravariant","page":"Home","title":"TrixiAtmo.global2contravariant","text":"global2contravariant(u, aux_vars, equations)\n\nTransform the vector u of solution variables with momentum or velocity components given with respect to the global coordinate system into local contravariant components. The  global coordinate system is specified by the GlobalCoordinateSystem type parameter in  AbstractCovariantEquations. u is a vector type of the correct length  nvariables(equations). Notice the function doesn't include any error checks for the  purpose of efficiency, so please make sure your input is correct. The inverse conversion is  performed by contravariant2global.\n\n\n\n\n\n","category":"function"},{"location":"#TrixiAtmo.have_aux_node_vars-Tuple{Trixi.AbstractEquations}","page":"Home","title":"TrixiAtmo.have_aux_node_vars","text":"have_aux_node_vars(equations)\n\nTrait function determining whether equations requires the use of auxiliary variables. Classical conservation laws such as the CompressibleEulerEquations2D do not  require auxiliary variables. The return value will be True() or False() to allow  dispatching on the return type.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.initial_condition_gaussian-Tuple{Any, Any, Any}","page":"Home","title":"TrixiAtmo.initial_condition_gaussian","text":"initial_condition_gaussian(x, t, equations)\n\nThis Gaussian bell case is a smooth initial condition suitable for testing the convergence  of discretizations of the linear advection equation on a spherical domain of radius a = 6 37122 times 10^3 mathrmm, representing the surface of the Earth. Denoting the  Euclidean norm as lVert cdot rVert, the initial height field is given by\n\nh(vecx) = h_0 exp\nBig(-b_0 big(lVert vecx - vecx_0 rVert  lVert vecx rVertbig)^2 Big)\n\nwhere h_0 = 1 times 10^3 mathrmm is the height of the bell, b_0 = 5 is the  width parameter, and vecx_0 is the position of the centre of the bell, which is  initialized at a longitude of 3pi2 and a latitude of zero. The velocity field  corresponds to a solid body rotation with a period of 12 days at an angle of  alpha = pi4 from the polar axis. Denoting vecomega as the corresponding angular velocity vector, the velocity is therefore initialized as\n\nvecv(vecx) = vecomega times vecx\n\nThis problem is adapted from Case 1 of the test suite described in the following paper:\n\nD. L. Williamson, J. B. Drake, J. J. Hack, R. Jakob, and P. N. Swarztrauber (1992). A   standard test set for numerical approximations to the shallow water equations in spherical geometry. Journal of Computational Physics, 102(1):211-224.  DOI: 10.1016/S0021-9991(05)80016-6\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.initial_condition_geostrophic_balance-Tuple{Any, Any, Any}","page":"Home","title":"TrixiAtmo.initial_condition_geostrophic_balance","text":"initial_condition_geostrophic_balance(x, t, equations)\n\nSteady geostrophic balance for the spherical shallow water equations, corresponding to a  purely zonal velocity field given as a function of the latitude theta by  v_lambda(theta) = v_0 costheta, where we define v_0 = 2pi a  (12  mathrmdays)  in terms of the Earth's radius a = 637122 times 10^3 mathrmm. The height field  then varies with the latitude as\n\nh(theta) = frac1g \nBig(gh_0 - Big(a Omega v_0 + frac12 v_0^2Big)sin^2thetaBig)\n\nwhere gh_0 = 294 times 10^4  mathrmm^2mathrms^2,  g = 980616  mathrmmmathrms^2, and  Omega = 7292 times 10^-5 mathrms^-1. This problem corresponds to Case 2 of the test suite described in the following paper:\n\nD. L. Williamson, J. B. Drake, J. J. Hack, R. Jakob, and P. N. Swarztrauber (1992). A   standard test set for numerical approximations to the shallow water equations in spherical geometry. Journal of Computational Physics, 102(1):211-224.  DOI: 10.1016/S0021-9991(05)80016-6\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.initial_condition_rossby_haurwitz-Tuple{Any, Any, Any}","page":"Home","title":"TrixiAtmo.initial_condition_rossby_haurwitz","text":"initial_condition_rossby_haurwitz(x, t, equations)\n\nRossby-Haurwitz wave case for the spherical shallow water equations, where the zonal and  meridional velocity components are given, respectively, as functions of the longitude  lambda and latitude theta by\n\nbeginaligned\nv_lambda(lambdatheta) = a omega cos theta+a K cos ^R-1 theta\nleft(R sin ^2 theta-cos ^2 thetaright) cos (R lambda)\nv_theta(lambdatheta) = -a K R cos ^R-1 theta sin theta sin (R lambda)\nendaligned\n\nwhere omega = K = 7848 times 10^-6  mathrms^-1 and R = 4 are given  constants, and a = 637122 times 10^3 mathrmm is the Earth's radius. Taking  g = 980616  mathrmmmathrms^2, Omega = 7292 times 10^-5  mathrms^-1,  and h_0 = 8000  mathrmm and defining the functions \n\nbeginaligned\nA(theta) =  fracomega2(2 Omega+omega) cos^2 theta + \nfrac14 K^2 cos^2 R thetaBig((R+1) cos^2theta +left(2 R^2-R-2right) - \nbig(2 R^2  cos^2 thetabig) Big) \nB(theta) = frac2(Omega+omega) K(R+1)(R+2) cos ^R thetabig((R^2+2 R+2) - \n(R+1)^2 cos^2 thetabig) \nC(theta) =  frac14 K^2 cos^2 R thetabig((R+1) cos^2 theta-(R+2)big)\nendaligned\n\nthe initial height field is given by\n\nh(lambdatheta) = h_0 + \nfraca^2gBig(A(theta) + B(theta)cos(Rlambda) + C(theta)cos(2Rlambda) Big)\n\nThis problem corresponds to Case 6 of the test suite described in the following paper:\n\nD. L. Williamson, J. B. Drake, J. J. Hack, R. Jakob, and P. N. Swarztrauber (1992). A   standard test set for numerical approximations to the shallow water equations in spherical geometry. Journal of Computational Physics, 102(1):211-224.  DOI: 10.1016/S0021-9991(05)80016-6\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.source_terms_lagrange_multiplier-Tuple{Any, Any, Any, Any, ShallowWaterEquations3D, Any}","page":"Home","title":"TrixiAtmo.source_terms_lagrange_multiplier","text":"source_terms_lagrange_multiplier(u, du, x, t,\n                                      equations::ShallowWaterEquations3D,\n                                      normal_direction)\n\nSource term function to apply a Lagrange multiplier to the semi-discretization in order to constrain the momentum to a 2D manifold.\n\nThe vector normal_direction is perpendicular to the 2D manifold. By default,  this is the normal contravariant basis vector.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.transform_initial_condition-Tuple{Any, TrixiAtmo.AbstractCovariantEquations}","page":"Home","title":"TrixiAtmo.transform_initial_condition","text":"transform_initial_condition(initial_condition, equations)\n\nTakes in a function with the signature initial_condition(x, t, equations) which returns  an initial condition given in terms of global Cartesian or zonal/meridional velocity components, and returns another function initial_condition_transformed(x, t, equations)  or initial_condition_transformed(x, t, aux_vars, equations) which returns the same  initial data, but transformed to the appropriate prognostic variables used internally by  the solver. For the covariant form, this involves a transformation of the global velocity  components to contravariant components using global2contravariant as well as a  conversion from primitive to conservative variables. For standard Cartesian formulations,  this simply involves a conversion from  primitive to conservative variables. The intention  here is to have a set of test cases (for example, initial_condition_gaussian) for  which the initial condition is prescribed using a standardized set of primitive variables  in a global coordinate system, and transformed to the specific prognostic variables  required for a given model.\n\nnote: Note\nWhen using the covariant formulation, the initial velocity components should be defined  in the coordinate system specified by the GlobalCoordinateSystem type parameter in AbstractCovariantEquations.\n\n\n\n\n\n","category":"method"}]
}
