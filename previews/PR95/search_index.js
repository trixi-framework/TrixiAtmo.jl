var documenterSearchIndex = {"docs":
[{"location":"#TrixiAtmo","page":"Home","title":"TrixiAtmo","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TrixiAtmo.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#TrixiAtmo.TrixiAtmo","page":"Home","title":"TrixiAtmo.TrixiAtmo","text":"üåç TrixiAtmo üåç\n\nTrixiAtmo.jl is a simulation package for atmospheric models based on Trixi.jl\n\nSee also: trixi-framework/TrixiAtmo.jl\n\n\n\n\n\n","category":"module"},{"location":"#TrixiAtmo.AbstractCovariantEquations","page":"Home","title":"TrixiAtmo.AbstractCovariantEquations","text":"AbstractCovariantEquations{NDIMS, \n                           NDIMS_AMBIENT, \n                           GlobalCoordinateSystem,\n                           NVARS} <: AbstractEquations{NDIMS, NVARS}\n\nAbstract type used to dispatch on systems of equations in covariant form, in which fluxes and prognostic variables are stored and computed in terms of their contravariant components  defining their expansions in terms of the local covariant tangent basis. The type parameter NDIMS denotes the dimension of the manifold on which the equations are solved, while NDIMS_AMBIENT is the dimension of the ambient space in which such a manifold is embedded.  Some references on discontinuous Galerkin methods in covariant flux form are listed below:\n\nM. Baldauf (2020). Discontinuous Galerkin solver for the shallow-water equations in covariant form on the sphere and the ellipsoid. Journal of Computational Physics  410:109384. DOI: 10.1016/j.jcp.2020.109384 \nM. Baldauf (2021). A horizontally explicit, vertically implicit (HEVI) discontinuous Galerkin scheme for the 2-dimensional Euler and Navier-Stokes equations using  terrain-following coordinates. Journal of Computational Physics 446:110635. DOI: 10.1016/ j.jcp.2021.110635\nL. Bao, R. D. Nair, and H. M. Tufo (2014). A mass and momentum flux-form high-order discontinuous Galerkin shallow water model on the cubed-sphere. A mass and momentum  flux-form high-order discontinuous Galerkin shallow water model on the cubed-sphere.  Journal of Computational Physics 271:224-243.  DOI: 10.1016/j.jcp.2013.11.033\n\nWhen using this equation type, functions which are evaluated pointwise, such as fluxes,  source terms, and initial conditions take in the extra argument aux_vars, which contains  the geometric information needed for the covariant form. The type parameter  GlobalCoordinateSystem specifies the global coordinate system used to define the  covariant tangent basis, and may be either GlobalCartesianCoordinates or  GlobalSphericalCoordinates. The GlobalCoordinateSystem type parameter also  specifies the coordinate system with respect to which the initial condition should be  prescribed.\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.CovariantLinearAdvectionEquation2D","page":"Home","title":"TrixiAtmo.CovariantLinearAdvectionEquation2D","text":"CovariantLinearAdvectionEquation2D{GlobalCoordinateSystem} <:  \n    AbstractCovariantEquations{2, 3, GlobalCoordinateSystem, 3}\n\nDenoting the covariant derivative by  nabla_j and summing over repeated indices, a variable-coefficient linear advection equation can be defined on a two-dimensional manifold in three-dimensional ambient space as\n\npartial_t h + nabla_j (hv^j) = 0\n\nWe treat this problem as a system of equations in which the first variable is the scalar  conserved quantity h, and the second two are the contravariant components v^1 and v^2  used in the expansion \n\nvecv = v^i veca_i =  v^1 veca_1 + v^2 veca_2\n\nwhere veca_1 = partial vecx  partial xi^1 and  veca_2 = partial vecx  partial xi^2 are the so-called covariant basis vectors,  and xi^1 and xi^2 are the local reference space coordinates. The velocity components  are spatially varying but assumed to be constant in time, so we do not apply any flux or  dissipation to such variables. The resulting system is then given on the reference element  as \n\nJ fracpartialpartial t\nleftbeginarrayc h  v^1  v^2 endarrayright \n+\nfracpartialpartial xi^1 \nleftbeginarrayc J h v^1  0  0 endarrayright\n+ \nfracpartialpartial xi^2 \nleftbeginarrayc J h v^2  0  0 endarrayright \n= \nleftbeginarrayc 0  0  0 endarrayright\n\nwhere J = lVertveca^1 times veca^2 rVert is the area element. Note that the  variable advection velocity components could alternatively be stored as auxiliary  variables, similarly to the geometric information.\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.CovariantShallowWaterEquations2D","page":"Home","title":"TrixiAtmo.CovariantShallowWaterEquations2D","text":"CovariantShallowWaterEquations2D{GlobalCoordinateSystem} <:  \n    AbstractCovariantEquations{2, 3, GlobalCoordinateSystem, 3}\n\nDenoting the covariant derivative by  nabla_j and summing over repeated indices, the shallow water equations can be expressed  on a two-dimensional surface in three-dimensional ambient space as\n\nbeginaligned\npartial_t h + nabla_j (hv^j) = 0\npartial_t (hv^i) + nabla_j tau^ij + gh G^ijpartial_j b\n= -fJ G^ijvarepsilon_jk hv^k\nendaligned\n\nwhere h is the geopotential height (equal to the total geopotential height H for zero bottom topography), v^i and G^ij are the contravariant velocity and metric tensor components, g is the gravitational acceleration, b is the bottom topography, f is the  Coriolis parameter, J is the area element, varepsilon is the Levi-Civita symbol, and  partial_j is used as a shorthand for partial  partial xi^j. The contravariant  momentum flux tensor components are given by\n\ntau^ij = hv^i v^j + frac12G^ijgh^2\n\nThe covariant shallow water equations with constant bottom topography can be formulated on  the reference element as a system of conservation laws with a source term (implemented in  the exported function source_terms_geometric_coriolis), as given by\n\nJ fracpartialpartial t\nleftbeginarrayc h  hv^1  hv^2 endarrayright \n+\nfracpartialpartial xi^1 \nleftbeginarrayc J h v^1  J tau^11  J tau^12 endarrayright\n+ \nfracpartialpartial xi^2 \nleftbeginarrayc J h v^2  J tau^21  J tau^22  endarrayright \n= J leftbeginarrayc 0  \n-Gamma^1_jktau^jk - f J big(G^12hv^1 - G^11hv^2big)  \n-Gamma^2_jktau^jk - f J big(G^22hv^1 - G^21hv^2big)\n endarrayright\n\nNote that the geometric contribution to the source term involves the Christoffel symbols of the second kind, which can been expressed in terms of the covariant metric tensor  components G_ij as \n\nGamma_jk^i = \nfrac12G^ilbig(partial_j G_kl + partial_k G_jl - partial_l G_jkbig)\n\nReferences\n\nM. Baldauf (2020). Discontinuous Galerkin solver for the shallow-water equations in covariant form on the sphere and the ellipsoid. Journal of Computational Physics  410:109384. DOI: 10.1016/j.jcp.2020.109384 \nL. Bao, R. D. Nair, and H. M. Tufo (2014). A mass and momentum flux-form high-order discontinuous Galerkin shallow water model on the cubed-sphere. A mass and momentum  flux-form high-order discontinuous Galerkin shallow water model on the cubed-sphere.  Journal of Computational Physics 271:224-243.  DOI: 10.1016/j.jcp.2013.11.033\n\nnote: Note\nWhen solving problems with variable bottom topography as well as when using entropy-stable schemes, SplitCovariantShallowWaterEquations2D should be used instead.\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.GlobalCartesianCoordinates","page":"Home","title":"TrixiAtmo.GlobalCartesianCoordinates","text":"GlobalCartesianCoordinates()\n\nStruct used for dispatch, specifying that the covariant tangent basis vectors should be  defined with respect to a global Cartesian coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.GlobalSphericalCoordinates","page":"Home","title":"TrixiAtmo.GlobalSphericalCoordinates","text":"GlobalSphericalCoordinates()\n\nStruct used for dispatch, specifying that the covariant tangent basis vectors should be  defined with respect to a global spherical coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.MetricTermsCrossProduct","page":"Home","title":"TrixiAtmo.MetricTermsCrossProduct","text":"MetricTermsCrossProduct()\n\nStruct used for multiple dispatch on functions that compute the metric terms. When the argument metric_terms is of type MetricTermsCrossProduct, the  contravariant vectors are computed using the cross-product form.\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.MetricTermsInvariantCurl","page":"Home","title":"TrixiAtmo.MetricTermsInvariantCurl","text":"MetricTermsInvariantCurl()\n\nStruct used for multiple dispatch on functions that compute the metric terms. When the argument metric_terms is of type MetricTermsInvariantCurl, the  contravariant vectors are computed using the invariant curl form.\n\nReferences\n\nKopriva, D. A. (2006). Metric identities and the discontinuous spectral element method on  curvilinear meshes. Journal of Scientific Computing 26, 301-327.  DOI: 10.1007/s10915-005-9070-8\nVinokur, M. and Yee, H. C. (2001). Extension of efficient low dissipation high order schemes for 3-D curvilinear moving grids. In Caughey, D. A., and Hafez, M. M. (eds.), Frontiers of Computational Fluid Dynamics 2002, World Scientific, Singapore, pp. 129‚Äì164. DOI: 10.1142/9789812810793_0008\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.ShallowWaterEquations3D","page":"Home","title":"TrixiAtmo.ShallowWaterEquations3D","text":"ShallowWaterEquations3D(; gravity, H0 = 0)\n\nShallow water equations (SWE) in three space dimensions in conservation form (with constant bottom topography).  The equations are given by\n\nbeginaligned\n  fracpartial hpartial t + fracpartialpartial x(h v_1)\n    + fracpartialpartial y(h v_2) + fracpartialpartial z(h v_3) = 0 \n    fracpartialpartial t(h v_1) + fracpartialpartial xleft(h v_1^2 + fracg2h^2right)\n    + fracpartialpartial y(h v_1 v_2) + fracpartialpartial z(h v_1 v_3) = 0 \n    fracpartialpartial t(h v_2) + fracpartialpartial x(h v_1 v_2)\n    + fracpartialpartial yleft(h v_2^2 + fracg2h^2right) + fracpartialpartial z(h v_2 v_3) = 0 \n    fracpartialpartial t(h v_3) + fracpartialpartial x(h v_1 v_3)\n    + fracpartialpartial y(h v_2 v_3) + fracpartialpartial zleft(h v_3^2 + fracg2h^2right) = 0\nendaligned\n\nThe unknown quantities of the SWE are the water height h and the velocities mathbfv = (v_1 v_2 v_3)^T. The gravitational acceleration is denoted by g.\n\nThe 3D Shallow Water Equations (SWE) extend the 2D SWE to model shallow water flows on 2D manifolds embedded within 3D space.  To confine the flow to the 2D manifold, a source term incorporating a Lagrange multiplier is applied.  This term effectively removes momentum components that are normal to the manifold, ensuring the flow remains  constrained within the 2D surface.\n\nThe additional quantity H_0 is also available to store a reference value for the total water height that is useful to set initial conditions or test the \"lake-at-rest\" well-balancedness.\n\nIn addition to the unknowns, Trixi.jl currently stores the bottom topography values at the approximation points despite being fixed in time. This is done for convenience of computing the bottom topography gradients on the fly during the approximation as well as computing auxiliary quantities like the total water height H or the entropy variables. This affects the implementation and use of these equations in various ways:\n\nThe flux values corresponding to the bottom topography must be zero.\nThe bottom topography values must be included when defining initial conditions, boundary conditions or source terms.\nAnalysisCallback analyzes this variable.\nTrixi.jl's visualization tools will visualize the bottom topography by default.\n\nReferences:\n\nJ. Cot√© (1988). \"A Lagrange multiplier approach for the metric terms of semi-Lagrangian models on the sphere\".  Quarterly Journal of the Royal Meteorological Society 114, 1347-1352. DOI: 10.1002/qj.49711448310\nF. X. Giraldo (2001). \"A spectral element shallow water model on spherical geodesic grids\".  DOI: 10.1002/1097-0363(20010430)35:8<869::AID-FLD116>3.0.CO;2-S\n\n\n\n\n\n","category":"type"},{"location":"#TrixiAtmo.SplitCovariantShallowWaterEquations2D","page":"Home","title":"TrixiAtmo.SplitCovariantShallowWaterEquations2D","text":"SplitCovariantShallowWaterEquations2D{GlobalCoordinateSystem} <:  \n    AbstractCovariantEquations{2, 3, GlobalCoordinateSystem, 3}\n\nAlternative flux formulation of CovariantShallowWaterEquations2D given on the  reference element by \n\nJ fracpartialpartial t\nleftbeginarrayc h  hv^1  hv^2 endarrayright \n+\nfracpartialpartial xi^1 \nleftbeginarrayc J h v^1  J h v^1 v^1  J h v^2 v^1 endarrayright\n+ \nfracpartialpartial xi^2 \nleftbeginarrayc J h v^2  J h v^1 v^2  J h v^2 v^2 endarrayright \n+\nJ leftbeginarrayc 0  Upsilon^1  Upsilon^2 endarrayright \n= \nJleftbeginarrayc0  s^1  s^2 endarrayright\n\nIn the above, the non-conservative differential terms in the momentum equations are given by\n\nUpsilon^i = frac12hv^jbig(G^ikpartial_j v_k - partial_j v^ibig) \n+ ghG^ijpartial_j (h + b)\n\nwhere we allow for a variable bottom topography defined by h_s, and the algebraic  momentum source terms implemented in source_terms_geometric_coriolis are given by\n\ns^i = -frac12big(Gamma_jk^i hv^j v^k - G^ikGamma_jk^lh v^j v_l big) \n- f JG^ijvarepsilon_jk hv^k\n\nIn the above, we employ the same notation as in CovariantShallowWaterEquations2D  (including summation over repeated indices) and note that the covariant velocity components are given by v_i = G_ij v^j. To obtain an entropy-conservative scheme with respect to  the total energy\n\neta = frac12h(v_1 v^1 + v_2v^2)  + frac12gh^2 + ghb\n\nthis equation type should be used with volume_flux = (flux_ec, flux_nonconservative_ec).\n\nwarning: Experimental implementation\nThe use of entropy-stable split-form/flux-differencing formulations for covariant  equations is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"type"},{"location":"#Trixi.flux_ec-Tuple{Any, Any, Any, Any, Integer, SplitCovariantShallowWaterEquations2D}","page":"Home","title":"Trixi.flux_ec","text":"Trixi.flux_ec(u_ll, u_rr, aux_vars_ll, aux_vars_rr,\n                           orientation::Integer,\n                           equations::SplitCovariantShallowWaterEquations2D)\n\nSymmetric part of an entropy-conservative flux for the shallow water equations in covariant  form. Note that this does not include the pressure term or the non-symmetric curvature  correction term. When used with flux_nonconservative_ec for the nonconservative volume and surface terms, this flux recovers the formulation described in the following  paper for the special case of the Euclidean metric G_ab = delta_ab:\n\nN. Wintermeyer, A. R. Winters, G. J. Gassner, and D. A. Kopriva (2017). An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on  unstructured curvilinear meshes with discontinuous bathymetry. Journal of Computational  Physics 300:240-242.  DOI: 10.1016/j.jcp.2017.03.036\n\nwarning: Experimental implementation\nThe use of entropy-stable split-form/flux-differencing formulations for covariant  equations is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"#Trixi.flux_fjordholm_etal-Tuple{Any, Any, AbstractVector, ShallowWaterEquations3D}","page":"Home","title":"Trixi.flux_fjordholm_etal","text":"flux_fjordholm_etal(u_ll, u_rr,\n                    normal_direction::AbstractVector,\n                    equations::ShallowWaterEquations3D)\n\nTotal energy conservative (mathematical entropy for shallow water equations). When the bottom topography is nonzero this should only be used as a surface flux otherwise the scheme will not be well-balanced. For well-balancedness in the volume flux use flux_wintermeyer_etal.\n\nDetails are available in Eq. (4.1) in the paper:\n\nUlrik S. Fjordholm, Siddhartha Mishra and Eitan Tadmor (2011) Well-balanced and energy stable schemes for the shallow water equations with discontinuous topography DOI: 10.1016/j.jcp.2011.03.042\n\n\n\n\n\n","category":"method"},{"location":"#Trixi.flux_wintermeyer_etal-Tuple{Any, Any, AbstractVector, ShallowWaterEquations3D}","page":"Home","title":"Trixi.flux_wintermeyer_etal","text":"flux_wintermeyer_etal(u_ll, u_rr,\n                      normal_direction::AbstractVector,\n                      equations::ShallowWaterEquations3D)\n\nTotal energy conservative (mathematical entropy for shallow water equations) split form. When the bottom topography is nonzero this scheme will be well-balanced when used as a volume_flux. For the surface_flux either flux_wintermeyer_etal or flux_fjordholm_etal can be used to ensure well-balancedness and entropy conservation.\n\nFurther details are available in Theorem 1 of the paper:\n\nNiklas Wintermeyer, Andrew R. Winters, Gregor J. Gassner and David A. Kopriva (2017) An entropy stable nodal discontinuous Galerkin method for the two dimensional shallow water equations on unstructured curvilinear meshes with discontinuous bathymetry DOI: 10.1016/j.jcp.2017.03.036\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.P4estMeshCubedSphere2D-Tuple{Any, Any}","page":"Home","title":"TrixiAtmo.P4estMeshCubedSphere2D","text":"P4estMeshCubedSphere2D(trees_per_face_dimension, radius;\n                        polydeg, RealT=Float64,\n                        initial_refinement_level=0, unsaved_changes=true,\n                        p4est_partition_allow_for_coarsening=true,\n                        element_local_mapping=false)\n\nBuild a \"Cubed Sphere\" mesh as a 2D P4estMesh with 6 * trees_per_face_dimension^2 trees.\n\nThe mesh will have no boundaries.\n\nArguments\n\ntrees_per_face_dimension::Integer: the number of trees in the two local dimensions of                                      each face.\nradius::Integer: the radius of the sphere.\npolydeg::Integer: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.\nRealT::Type: the type that should be used for coordinates.\ninitial_refinement_level::Integer: refine the mesh uniformly to this level before the simulation starts.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\np4est_partition_allow_for_coarsening::Bool: Must be true when using AMR to make mesh adaptivity independent of domain partitioning. Should be false for static meshes to permit more fine-grained partitioning.\nelement_local_mapping::Bool: option to use the alternative element-local mapping from Appendix A of Guba et al. (2014). If set to  true, the four corner vertex positions for each element will be obtained through an  equiangular gnomonic projection (Ronchi et al. 1996), and the tree node coordinates within the element (i.e. the field  tree_node_coordinates) will be obtained by first using a bilinear mapping based on the  four corner vertices, and then projecting the bilinearly mapped nodes onto the spherical  surface by normalizing the resulting Cartesian coordinates and scaling by  radius. If  set to false, the equiangular gnomonic projection will be used for all tree node  coordinates.\n\nwarning: Warning\nAdaptivity and MPI parallelization are not yet supported for equations in covariant  form, and we require initial_refinement_level = 0 for such cases. Furthermore, the  calculation of the metric terms for the covariant form currently requires polydeg to  be equal to the polynomial degree of the solver, and element_local_mapping = true.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.P4estMeshQuadIcosahedron2D-Tuple{Any, Any}","page":"Home","title":"TrixiAtmo.P4estMeshQuadIcosahedron2D","text":"P4estMeshQuadIcosahedron2D(trees_per_face_dimension, radius;\n                           polydeg, RealT=Float64,\n                           initial_refinement_level=0, unsaved_changes=true,\n                           p4est_partition_allow_for_coarsening=true)\n\nBuild a quad-based icosahedral mesh as a 2D P4estMesh with 60 * trees_per_face_dimension^2 trees (20 triangular faces of the icosahedron, each subdivided into 3 parent quads, each of which subdivided into trees_per_face_dimension^2 trees).\n\nThe node coordinates of the trees will be obtained using the element-local mapping from Appendix A of Guba et al. (2014).  See P4estMeshCubedSphere2D for more information about the element-local mapping.\n\nThe mesh will have no boundaries.\n\nArguments\n\ntrees_per_face_dimension::Integer: the number of trees in the two local dimensions of                                      each parent quad.\nradius::Integer: the radius of the sphere.\npolydeg::Integer: polynomial degree used to store the geometry of the mesh.                     The mapping will be approximated by an interpolation polynomial                     of the specified degree for each tree.\nRealT::Type: the type that should be used for coordinates.\ninitial_refinement_level::Integer: refine the mesh uniformly to this level before the simulation starts.\nunsaved_changes::Bool: if set to true, the mesh will be saved to a mesh file.\np4est_partition_allow_for_coarsening::Bool: Must be true when using AMR to make mesh adaptivity independent of domain partitioning. Should be false for static meshes to permit more fine-grained partitioning.\n\nwarning: Warning\nAdaptivity and MPI parallelization are not yet supported for equations in covariant  form, and we require initial_refinement_level = 0 for such cases. Furthermore, the  calculation of the metric terms for the covariant form currently requires polydeg to  be equal to the polynomial degree of the solver.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.clean_solution_lagrange_multiplier!-Tuple{Any, ShallowWaterEquations3D, Any}","page":"Home","title":"TrixiAtmo.clean_solution_lagrange_multiplier!","text":"     clean_solution_lagrange_multiplier!(u, equations::ShallowWaterEquations3D, normal_direction)\n\nFunction to apply Lagrange multiplier discretely to the solution in order to constrain  the momentum to a 2D manifold.\n\nThe vector normal_direction is perpendicular to the 2D manifold. By default,  this is the normal contravariant basis vector.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.contravariant2global","page":"Home","title":"TrixiAtmo.contravariant2global","text":"contravariant2global(u, aux_vars, equations)\n\nTransform the vector u of solution variables with the momentum or velocity given in terms  of local contravariant components into the global coordinate system specified by the  GlobalCoordinateSystem type parameter in AbstractCovariantEquations. u is a  vector type of the correct length nvariables(equations). Notice the function doesn't  include any error checks for the purpose of efficiency, so please make sure your input is  correct. The inverse conversion is performed by global2contravariant.\n\n\n\n\n\n","category":"function"},{"location":"#TrixiAtmo.examples_dir-Tuple{}","page":"Home","title":"TrixiAtmo.examples_dir","text":"examples_dir()\n\nReturn the directory where the example files provided with TrixiAtmo.jl are located. If TrixiAtmo.jl is installed as a regular package (with ]add Trixi), these files are read-only and should not be modified. To find out which files are available, use, e.g., readdir:\n\nExamples\n\nreaddir(examples_dir())\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.flux_nonconservative_ec-Tuple{Any, Any, Any, Any, Integer, SplitCovariantShallowWaterEquations2D}","page":"Home","title":"TrixiAtmo.flux_nonconservative_ec","text":"flux_nonconservative_ec(u_ll, u_rr, aux_vars_ll, aux_vars_rr,\n                        orientation::Integer,\n                        equations::SplitCovariantShallowWaterEquations2D)\n\nNon-symmetric part of an entropy-conservative flux for the shallow water equations in    covariant form, consisting of pressure and bottom topography terms, as well as a    curvature correction term. This can be used for both the volume and surface terms.\n\nwarning: Experimental implementation\nThe use of entropy-stable split-form/flux-differencing formulations for covariant  equations is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.flux_nonconservative_surface_simplified-Tuple{Any, Any, Any, Any, Integer, SplitCovariantShallowWaterEquations2D}","page":"Home","title":"TrixiAtmo.flux_nonconservative_surface_simplified","text":"flux_nonconservative_surface_simplified(u_ll, u_rr, aux_vars_ll, aux_vars_rr,\n                                        orientation::Integer,\n                                        equations::SplitCovariantShallowWaterEquations2D)\n\nFor bottom topography which is continuous across element interfaces, we can significantly    simplify the nonconservative surface terms, such that only the pressure contribution    remains. In such cases, this flux is equivalent to flux_nonconservative_ec when used as a surface flux, but should not be used as a volume flux.\n\nwarning: Experimental implementation\nThe use of entropy-stable split-form/flux-differencing formulations for covariant  equations is an experimental feature and may change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.global2contravariant","page":"Home","title":"TrixiAtmo.global2contravariant","text":"global2contravariant(u, aux_vars, equations)\n\nTransform the vector u of solution variables with momentum or velocity components given with respect to the global coordinate system into local contravariant components. The  global coordinate system is specified by the GlobalCoordinateSystem type parameter in  AbstractCovariantEquations. u is a vector type of the correct length  nvariables(equations). Notice the function doesn't include any error checks for the  purpose of efficiency, so please make sure your input is correct. The inverse conversion is  performed by contravariant2global.\n\n\n\n\n\n","category":"function"},{"location":"#TrixiAtmo.have_aux_node_vars-Tuple{Trixi.AbstractEquations}","page":"Home","title":"TrixiAtmo.have_aux_node_vars","text":"have_aux_node_vars(equations)\n\nTrait function determining whether equations requires the use of auxiliary variables. Classical conservation laws such as the CompressibleEulerEquations2D do not  require auxiliary variables. The return value will be True() or False() to allow  dispatching on the return type.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.initial_condition_barotropic_instability-Tuple{Any, Any, Any}","page":"Home","title":"TrixiAtmo.initial_condition_barotropic_instability","text":"initial_condition_barotropic_instability(x, t, equations)\n\nBarotrotropic instability initiated by a perturbation applied to a mid-latitude jet. The  velocity field is a purely zonal flow, given as a function of the latitude theta as\n\nv_lambda(theta) = begincases\nu_0 exp(-4  (theta_1 - theta_0)^-2)exp((theta - theta_0)^-1\n(theta - theta_1)^-1)  quad theta_0  theta  theta_1 \n0  quad textotherwise\nendcases\n\nwhere u_0 = 80  mathrmmmathrms, theta_0 = pi7, and  theta_1 = pi2 - theta_0. The background geopotential height field is given by \n\nh_0(theta) = 10158  mathrmm - \nfracag int_-pi2^theta v_lambda(theta)big(2Omegasintheta + \nv_lambda(theta)tantheta  a big) mathrmdtheta\n\nwhere a = 637122 times 10^3 mathrmm is the Earth's radius,  g = 980616  mathrmmmathrms^2 is the Earth's gravitational acceleration, and Omega = 7292 times 10^-5 mathrms^-1 is the Earth's rotation rate. The  perturbation is then added to obtain the following geopotential height field:\n\nh(lambda theta) = begincases\nh_0(theta) + delta h costheta exp(-(lambdaalpha)^2) \nexp(-((theta_2 -theta)beta)^2)  quad -pi  lambda  pi\nh_0(theta)  quad textotherwise\nendcases\n\nwhere lambda is the longitude coordinate, and we take alpha = 13, beta = 115,  and delta h = 120  mathrmm. This problem was proposed in the following paper:\n\nJ. Galewsky, R. K. Scott, and L. M. Polvani (2004). An initial-value problem for testing numerical models of the global shallow-water equations. Tellus A 56.5:429‚Äì440. DOI: 10.3402/tellusa.v56i5.14436\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.initial_condition_gaussian-Tuple{Any, Any, Any}","page":"Home","title":"TrixiAtmo.initial_condition_gaussian","text":"initial_condition_gaussian(x, t, equations)\n\nThis Gaussian bell case is a smooth initial condition suitable for testing the convergence  of discretizations of the linear advection equation on a spherical domain of radius a = 6 37122 times 10^3 mathrmm, representing the surface of the Earth. Denoting the  Euclidean norm as lVert cdot rVert, the initial height field is prescribed as a  function of the position vecx relative to the centre of the Earth by\n\nh(vecx) = h_0 exp\nBig(-b_0 big(lVert vecx - vecx_0 rVert  lVert vecx rVertbig)^2 Big)\n\nwhere h_0 = 1 times 10^3 mathrmm is the height of the bell, b_0 = 5 is the  width parameter, and vecx_0 is the position of the centre of the bell, which is  initialized at a longitude of 3pi2 and a latitude of zero. The velocity field  corresponds to a solid body rotation with a period of 12 days at an angle of  alpha = pi4 from the polar axis. Denoting vecomega as the corresponding angular velocity vector, the velocity is therefore initialized as\n\nvecv(vecx) = vecomega times vecx\n\nThis problem is adapted from Case 1 of the test suite described in the following paper:\n\nD. L. Williamson, J. B. Drake, J. J. Hack, R. Jakob, and P. N. Swarztrauber (1992). A   standard test set for numerical approximations to the shallow water equations in spherical geometry. Journal of Computational Physics, 102(1):211-224.  DOI: 10.1016/S0021-9991(05)80016-6\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.initial_condition_geostrophic_balance-Tuple{Any, Any, Any}","page":"Home","title":"TrixiAtmo.initial_condition_geostrophic_balance","text":"initial_condition_geostrophic_balance(x, t, equations)\n\nSteady geostrophic balance for the spherical shallow water equations, corresponding to a  purely zonal velocity field given as a function of the latitude theta by  v_lambda(theta) = v_0 costheta, where we define v_0 = 2pi a  (12  mathrmdays)  in terms of the Earth's radius a = 637122 times 10^3 mathrmm. The height field  then varies with the latitude as\n\nh(theta) = frac1g \nBig(gh_0 - Big(a Omega v_0 + frac12 v_0^2Big)sin^2thetaBig)\n\nwhere gh_0 = 294 times 10^4  mathrmm^2mathrms^2,  g = 980616  mathrmmmathrms^2, and  Omega = 7292 times 10^-5 mathrms^-1. This problem corresponds to Case 2 of the test suite described in the following paper:\n\nD. L. Williamson, J. B. Drake, J. J. Hack, R. Jakob, and P. N. Swarztrauber (1992). A   standard test set for numerical approximations to the shallow water equations in spherical geometry. Journal of Computational Physics, 102(1):211-224.  DOI: 10.1016/S0021-9991(05)80016-6\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.initial_condition_isolated_mountain-Tuple{Any, Any, Any}","page":"Home","title":"TrixiAtmo.initial_condition_isolated_mountain","text":"initial_condition_isolated_mountain(x, t, equations)\n\nZonal flow over an isolated mountain with a profile given in terms of the latitude  lambda and longitude theta as \n\nh_s(lambdatheta) =\nh_s0 (1 - sqrtmin(R^2 (lambda-lambda_0)^2 + (theta-theta_0)^2)R)\n\nwhere h_s0 = 2000  textm, lambda_0 = -pi2, theta_0 = pi6, and R =pi9.  The initial velocity field is given by v_lambda(theta) = v_0 costheta, where  v_0 = 20  mathrmms, and the total geopotential height H = h+h_s is given by \n\nH(theta) = H_0 - frac1gBig(a Omega v_0 + frac12 v_0^2Big)sin^2theta\n\nwhere H_0 = 5960  mathrmm, g = 980616  mathrmmmathrms^2, and  Omega = 7292 times 10^-5 mathrms^-1. To use this test case with  SplitCovariantShallowWaterEquations2D, the keyword argument  auxiliary_field = bottom_topography_isolated_mountain should be passed into the  SemidiscretizationHyperbolic constructor. This problem corresponds to Case 5 of the test suite described in the following paper:\n\nD. L. Williamson, J. B. Drake, J. J. Hack, R. Jakob, and P. N. Swarztrauber (1992). A   standard test set for numerical approximations to the shallow water equations in spherical geometry. Journal of Computational Physics, 102(1):211-224.  DOI: 10.1016/S0021-9991(05)80016-6\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.initial_condition_rossby_haurwitz-Tuple{Any, Any, Any}","page":"Home","title":"TrixiAtmo.initial_condition_rossby_haurwitz","text":"initial_condition_rossby_haurwitz(x, t, equations)\n\nRossby-Haurwitz wave case for the spherical shallow water equations, where the zonal and  meridional velocity components are given, respectively, as functions of the longitude  lambda and latitude theta by\n\nbeginaligned\nv_lambda(lambdatheta) = a omega cos theta+a K cos ^R-1 theta\nleft(R sin ^2 theta-cos ^2 thetaright) cos (R lambda)\nv_theta(lambdatheta) = -a K R cos ^R-1 theta sin theta sin (R lambda)\nendaligned\n\nwhere omega = K = 7848 times 10^-6  mathrms^-1 and R = 4 are given  constants, and a = 637122 times 10^3 mathrmm is the Earth's radius. Taking  g = 980616  mathrmmmathrms^2, Omega = 7292 times 10^-5  mathrms^-1,  and h_0 = 8000  mathrmm and defining the functions \n\nbeginaligned\nA(theta) = fracomega2(2 Omega+omega) cos^2 theta + \nfrac14 K^2 cos^2 R thetaBig((R+1) cos^2theta +left(2 R^2-R-2right) - \nbig(2 R^2  cos^2 thetabig) Big) \nB(theta) = frac2(Omega+omega) K(R+1)(R+2) cos ^R thetabig((R^2+2 R+2) - \n(R+1)^2 cos^2 thetabig) \nC(theta) =  frac14 K^2 cos^2 R thetabig((R+1) cos^2 theta-(R+2)big)\nendaligned\n\nthe initial height field is given by\n\nh(lambdatheta) = h_0 + \nfraca^2gBig(A(theta) + B(theta)cos(Rlambda) + C(theta)cos(2Rlambda) Big)\n\nThis problem corresponds to Case 6 of the test suite described in the following paper:\n\nD. L. Williamson, J. B. Drake, J. J. Hack, R. Jakob, and P. N. Swarztrauber (1992). A   standard test set for numerical approximations to the shallow water equations in spherical geometry. Journal of Computational Physics, 102(1):211-224.  DOI: 10.1016/S0021-9991(05)80016-6\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.initial_condition_unsteady_solid_body_rotation-Tuple{Any, Any, Any}","page":"Home","title":"TrixiAtmo.initial_condition_unsteady_solid_body_rotation","text":"initial_condition_unsteady_solid_body_rotation(x, t, equations)\n\nUnsteady analytical solution to the spherical shallow water equations, corresponding to a solid body rotation with a prescribed bottom topography. Assuming the domain to be a sphere  of radius a = 637122 times 10^3 mathrmm, letting vecx denote the position  relative to the centre of the Earth, and letting vece_x, vece_y, and vece_z  denote the Cartesian basis vectors, we define the rotating frame \n\nvecb_x(t) = cos(Omega t)vece_x + sin(Omega t)vece_y quad\nvecb_y(t) = -sin(Omega t)vece_x + cos(Omega t)vece_y quad \nvecb_z(t) = vece_z\n\nas a function of time t. We also define the associated coordinate transformation \n\nvecvarphi(vecxt) = \n(vecx cdot vecb_x(t)) vece_x + (vecx cdot vecb_y(t)) vece_y + \n(vecx cdot vecb_z(t)) vece_z\n\nas well as a fixed axis vecc = -sin(alpha)vece_x + cos(alpha)vece_y, where  Omega = 7292 times 10^-5 mathrms^-1 is the Earth's rotation rate, and we take  alpha = pi4. For a bottom topography prescribed as\n\nh_s(vecx) = frac12g(vecOmega cdot vecx)^2\n\nwhere vecOmega = Omegavece_z and g = 980616  mathrmmmathrms^2 are the  Earth's axis of rotation and gravitational acceleration, respectively, the time-dependent  velocity field is given as \n\nvecv(vecxt) = v_0 vecvarphi(vecct) times vecxlVert vecx rVert\n\nand the total geopotential height H = h+b is given by \n\nH(vecxt) = \nfrac12gleft(big(v_0 vecOmegacdot vecx - \nvecvarphi(vecct) cdot vecxlVert vecx rVert big)^2 +\n(vecOmega cdot vecx)^2 + 2k_1right)\n\nwhere v_0 = 2pi a  (12  mathrmdays), k_1 = 133681  mathrmm^2mathrms^2, and lVert cdot rVert denotes the Euclidean norm. To use this test case with SplitCovariantShallowWaterEquations2D, the keyword argument auxiliary_field = bottom_topography_unsteady_solid_body_rotation should be passed into the SemidiscretizationHyperbolic constructor. This analytical solution was derived in the following paper:\n\nM. L√§uter, D. Handorf, and K. Dethloff (2005). Unsteady analytical solutions of the  spherical shallow water equations. Journal of Computational Physics 210:535‚Äì553. DOI: 10.1016/j.jcp.2005.04.022\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.source_terms_lagrange_multiplier-Tuple{Any, Any, Any, Any, ShallowWaterEquations3D, Any}","page":"Home","title":"TrixiAtmo.source_terms_lagrange_multiplier","text":"source_terms_lagrange_multiplier(u, du, x, t,\n                                      equations::ShallowWaterEquations3D,\n                                      normal_direction)\n\nSource term function to apply a Lagrange multiplier to the semi-discretization in order to constrain the momentum to a 2D manifold.\n\nThe vector normal_direction is perpendicular to the 2D manifold. By default,  this is the normal contravariant basis vector.\n\n\n\n\n\n","category":"method"},{"location":"#TrixiAtmo.transform_initial_condition-Tuple{Any, TrixiAtmo.AbstractCovariantEquations}","page":"Home","title":"TrixiAtmo.transform_initial_condition","text":"transform_initial_condition(initial_condition, equations)\n\nTakes in a function with the signature initial_condition(x, t, equations) which returns  an initial condition given in terms of global Cartesian or zonal/meridional velocity components, and returns another function initial_condition_transformed(x, t, equations)  or initial_condition_transformed(x, t, aux_vars, equations) which returns the same  initial data, but transformed to the appropriate prognostic variables used internally by  the solver. For the covariant form, this involves a transformation of the global velocity  components to contravariant components using global2contravariant as well as a  conversion from primitive to conservative variables. For standard Cartesian formulations,  this simply involves a conversion from  primitive to conservative variables. The intention  here is to have a set of test cases (for example, initial_condition_gaussian) for  which the initial condition is prescribed using a standardized set of primitive variables  in a global coordinate system, and transformed to the specific prognostic variables  required for a given model.\n\nnote: Note\nWhen using the covariant formulation, the initial velocity components should be defined  in the coordinate system specified by the GlobalCoordinateSystem type parameter in AbstractCovariantEquations.\n\n\n\n\n\n","category":"method"}]
}
